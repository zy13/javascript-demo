## 面向对象
- 对象：属性和方法的封装
- 对象特征：抽象、封装、继承、多态
- 创建方式：
  - 1.字面量
  - 2.构造函数`new Object()`
  - 3.Object.create(): 创建属性方法挂载在原型上
## 工厂模式
- 优点：解决代码复用问题
- 缺点：
  - 无法解决对象识别问题
  - 没有原型，占用内存

## new运算符
- 执行函数
- 创建一个空对象
- this执行空对象
- 若无返回值，隐形返还this
- 改造工厂模式

## 构造函数及静态成员
- 首字母大写
- 通过new调用
- 其this指向实例化对象
- 静态属性和方法：只能构造函数本身调用，实例化对象不能调用
- 静态方法中的this：指向构造函数本身

## 构造函数性能
- 没有原型，占用内存

## 原型
- 原型是一个对象，提供一个公共空间，用来挂载公共方法
- 任何对象和方法都有原型
- 原型有一个固有属性constructor，指向原型本身
- 通过constructor可以判断类型

## 三者关系-原型、构造函数、对象

- 构造函数
  -(1) 含有原型prototype对象属性
  -(2) 通过new命令实例化对象
  -(3) 其this 指向实例化对象
- 原型
  -(1) 含有固有属性constructor, 其指向原型所属的构造函数
  -(2) 其this指向原型所属的构造函数的实例化对象
  -(3) 原型（prototype）与实例化对象的原型（proto）恒等

## 工厂模式对比构造函数
- 无法解决对象识别问题
- 没有原型，占用内存

## 原型链

对象之间的继承关系，在JavaScript中是通过`prototype`对象指向父类对象，直到指向`Object`对象为止，这样就形成了一个`原型指向的链条`，称之为原型链

## call, apply, bind

Function对象自带的三个函数：call, apply, bind，能将函数的this指向指定的对象上。
三者间传入的参数形式不一样：
- **call**
  - 参数个数没有上限
  - 第一个参数为this指定的对象
  - 后面参数为传给函数的实参
- **apply**
  - 最多有两个参数
  - 第一个参数为this指定的对象
  - 第二个参数为数组，数组元素为传给函数的实参
- **bind**
  - 执行两次
  - 执行第一次时，传入this指定的对象，返回函数本身
  - 执行第二次时，传入函数的实参
- 三者均可实现构造函数的继承

## 构造函数的继承

- 使用`call`、`apply`、`bind`实现继承
- 无法继承父类原型prototype中的属性和方法
## 原型的继承
- 简单的原型继承，会影响到父类，比如重写原型的方法和属性
## 传值和传址
- 基本数据类型 - **传值**：`Number`、`String`、`Boolean`、`Null`、`Undefined`
- 复杂数据类型/引用数据类型 - **传址**: `Array`、`Date`、`Math`、`RegExp`、`Object`、`Function`等
- **浅拷贝**：`JSON序列化`
  - 如果拷贝对象包含函数，或者undefined等值，此方法就会出现问题
  - 无法拷贝函数和undefined的属性
- `深拷贝`: 递归遍历

## 原型深拷贝继承
- 子类原型对父类原型进行深拷贝：`Son.prototype = deepCopy(Dad.prototype);`

## 16、组合继承
- 组合继承，替换深拷贝
  - 创建一个中间类Link
  - Link的prototype继承父类Dad的prototype
  - 子类Son的prototype继承Link的prototype
  - 子类的prototype的constructor指向自己