<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    class Promise{
      constructor(handle) {
        this['[[PromiseState]]'] = 'pending'
        this['[[PromiseResult]]'] = 'undefined'
        this.resolveFnQueue = []      
        this.rejectFnQueue = []
        handle(this._resolve.bind(this), this._reject.bind(this))
      }
      _resolve(val) {
        this['[[PromiseState]]'] = 'fulfilled'
        this['[[PromiseResult]]'] = val
        // 微任务-所有同步任务执行后才开始执行微任务
        let run = () => {
          let cb
          while (cb = this.resolveFnQueue.shift()) {
            cb(val)
          }
        }
        let mo = new MutationObserver(run)
        mo.observe(document.body,{
          attributes: true
        })
        document.body.setAttribute('kkb', 'kkb')
      }
      _reject(err) {
        this['[[PromiseState]]'] = 'rejected'
        this['[[PromiseResult]]'] = err
        // 微任务-所有同步任务执行后才开始执行微任务
        let run = () => {
          let cb
          while (cb = this.rejectFnQueue.shift()) {
            cb(err)
          }
        }
        let mo = new MutationObserver(run)
        mo.observe(document.body,{
          attributes: true
        })
        document.body.setAttribute('kkb', 'kkb')
      }
      then(onResolve, onReject) {
        // then原则：只存储回调函数，不执行回调函数
        // 链式调用
        return new Promise((resolve, reject) => {
          let onResolveFn = (val) => {
            let res = onResolve && onResolve(val)
            if(res instanceof Promise) {
              res.then(resolve)
            } else {
              resolve(res)
            }
          }
          let onRejectFn = (err) => {
            reject(err)
          }
          this.resolveFnQueue.push(onResolveFn)
          this.rejectFnQueue.push(onReject)
        })
      }
      static resolve(val) {
        return new Promise(resolve => {
          resolve(val)
        })
      }
      static reject(err) {
        return new Promise((undefined, reject) => {
          reject(err)
        })
      }
      static all(list) {
        // 所有函数都resolve才返回的结果列表
        return new Promise((resolve, reject) => {
          let resArr = []
          list.forEach(item => {
            item.then(res => {
              resArr.push(res)
              if(resArr.length === list.length) {
                resolve(resArr)
              }
            },err => {
              reject('err')
            })
          })
        })
      }
      static allSettled(list) {
        return new Promise((resolve, reject) => {
          let resArr = []
          list.forEach(item => {
            item.then(res => {
              resArr.push(res)
              if(resArr.length === list.length) {
                resolve(resArr)
              }
            }, err => {
              resArr.push(err)
              if(resArr.length === list.length) {
                resolve(resArr)
              }
            })
          })
        })
      }
      static race(list) {
        return new Promise((resolve,reject) => {
          list.forEach(item => {
            item.then(res => {
               resolve(res)
            }, err => {
              reject(err)
            })
          })
        })
      }
    }
    const p1 = new Promise((resolve, reject) => {
      resolve('11')
      // reject('err')
    })

    const p2 = new Promise((resolve, reject) => {
      resolve('22')
    })
    Promise.all([p1,p2]).then(res => {
      console.log(77, res);
    }, err => {
      console.log(err);
    })
    Promise.race([p1,p2]).then(res => {
      console.log(88, res);
    })
  </script>
</body>
</html>